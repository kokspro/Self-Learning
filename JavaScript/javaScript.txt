FUN SHORTCUTS FOR ME:
    Highlight and ( will place them outside
    Highlight + Alt + Arrow moves
    Highlight name and ctrl + d lets you change all of them 

NPM NOT WORKING
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

LINKS:
<script src="source_name"></script> ---- How to link js to hrml

BASICS:
    OBJECTS:
        REFERENCE TYPES:
            OBJECT:
                let person = {
                    name: 'Mosh',
                    age: 40
                };
                person.name;
                person['name'];
            ARRAY:
                let selected = [];
            FUNCTION:
                function nameIt() {}

OPERATORS:
    //Leaving out universal/common knowledge
    ARITHMETIC OPERATORS:
    ASSIGNMENT OPERATORS:
    COMPARISON OPERATORS:
    EQUALITY OPERATORS:
        === (Equals) (Strict Equality Same Type + Value)
        !== (Does not Equal)
        ==  (Equals) (Loose Equality converts the right side type to match left side type, checks values after)
        != (Does not Equal)
    TERNARY OPERATORS:
        conditional ? 'true option' : 'false option';
    LOGICAL OPERATORS:
    LOGICAL OPERATORS WITH NON-BOOLEANS:
        Falsy (false):
            undefined
            null
            0
            false
            ''
            NaN
        Truthy (true):
            Anything NOT Falsy
    BITWISE OPERATORS:
            Technical and super niche, not taking notes.   
            Can always go back and refresh if I need.
            It is just logical using bits, easy peasy actually.

CONTROL FLOW:
    IF ELSE:
    SWITCH CASE:
        switch (role) {
            case 'value':
                statement;
                break;
            default:
                statement;
        }
    FOR:
        for (let i = 0; i <= 10; i++) {}
    WHILE:
    DO WHILE:
    FOR IN: - Better for properties of an object
        for (let var in otherThing) {}
    FOR OF: - Better for elements in an array
        for (let var of array?) {}
    BREAK AND CONTINUE:
        break; to exit a loop
        continue; to jump to top of loop

OBJECTS:
    FACTORY:
        function createCircle() {
            const circle =  {
               radius: 1,
               location: {
                    x: 1,
                    y: 1
                },
                isVisible: true,
               draw: function() {
                  console.log('draw');
                }
            };
        return circle; 
        }
        More concise factory function in app.js

    CONSTRUCTOR:
        USE PASCAL NOTATION: OneTwoThreeFour, first of each caps 
        Example in app.js

    CLONING:
        Use a for in loop with bracket notation, easy peasy
        Or, Object.assign  Example in app.js
        Or, const another = { ...object }

    MATH:
        Math.random() * (max - min) + min; for random in range
    
    STRING:
        String primitives get turned into wrapped in object with dot notation
        Docs for sure.
        .replace creates a new string and does not modify the original
        Excape notation is a thing using \

    TEMPLATE LITERALS:
        ${} is for variable

    DATE:
        const date = new Date(); 
        can use up and down arrows to display how dates is displayed
        Month is 0 based
        .toDateString()
        .toTimeString()
        .toISOString()
        These are good ways to record for applications and talk with server (ISO)

    
ARRAYS:
    ADDING:
        array.push(adds to the end)
        array.unshift(adds to beginning)
        array.splice(start index, number of elements to delete, however many elements to add)
    FINDING ELEMENTS:
        PRIMITIVES:
            array.indexOf()
            array.lastIndexOf()
            array.includes()
            Searches can have an optional parameter of index to start searching from
        REFERENCE TYPES(OBJECT):
            Little more complicated, maybe refresh, example in app.js   
            array.find(function(element) {body})
            array.findIndex(function(element) {body})
    ARROW FUNCTIONS:
        Example under previous example in app.js
    REMOVING ELEMENTS:
        array.pop() removes from the end and returns It
        array.shift() removes from the front, returns It
        array.splice(element start, number of elements to remove, elements to add)
    EMPTYING:
        reassign array (can't be used if const)
        array.length = 0; will truncate the array
        array.splice(0, array.length);
    COMBINING AND SLICING:
        array1.concat(array2); returns new array, doesn't change originals
        array.slice(start(optional), finish-excluding(optional))
        If using primitives, they are copied
        If using objects, references are copied, so they point to the same thing
    SPREAD OPERATOR:
        const combined = [...array1, ...array2];
    ITERATING AN ARRAY:
        for of loop for array
        array.forEach(function(number) {
           console.log(number);
        });    
        array.forEach(number => console.log(number)); faster way
        Optional adding done in app.js    
    JOINING ARRAYS:
        array.join('what to separate them by'), returns a string
        string.split('where to split (' ' split on spaces)'), this works on a string not an array but returns an array
    SORTING ARRAYS:
        array.sort();, turns them into strings and sorts by that
        array.reverse(); reverses the array
        Object sorting done in app.js
    TESTING ELEMENTS OF AN ARRAY:
        array.every(function(value), optional index, optional array), returns a BOOLEANS
        array.some = same thing but checks if at least 1 fits the function
    FILTERING AN ARRAY:
        Example in app.js
        array.filter(function()) as with some previous methods
    MAPPING AN ARRAY:
        array.map(function()), can set them to say HTML elements, will return an array
        then can join them 
        can also map to objects
        if mapping to object you cannot exclude default {}
        filter and map return new arrays, they do not alter the original
    REDUCING AN ARRAY:
        example in app.js
        takes two parameters, accumulator and currentValue
        second parameter after function is starting value of accumulator
               

FUNCTIONS:
        function name() {}; - Function Delcaration
        let varName = function() {}; - Anonymous Function Expression
        let varName = function name() {}; - Named Function Expression
        varName(); - Runs the function
    HOISTING:
        You can call declared functions before the declaration (opposite of Java, C, etc.).
        You cannot do that for Function Expressions.
        JavaScript engine moves all function delcarations to the top at runtime.
    ARGUMENTS:
        "arguments" is an object in js
        You can use a for of loop to make sure to iterate over all parameters sent and not have to reference them in the function delcarations
        function sum() { loop over (let value of arguments) and add to variable to store total}
    REST OPERATOR:
        ...arguments
        Rest parameter MUST be the last parameter. 
    DEFAULT PARAMETERS:
        Set them in the parameters
        function interest(principal, rate = 3.5, years = 5) {}
        Rate and years have a default value 
        Default values need to be at the end like the REST OPERATORS
    GETTERS AND SETTERS:
        Getters access properties in an object
        Setters alter or mutate properties in an object
    TRY CATCH BLOCK:
        Example in app.js
    THIS KEYWORD:
        this represents the object that is executing the current function
        Arrow functions maintain the this value
        
            
Starting OOP/Advanced JS 

PILLARS OF OOP:
    ENCAPSULATION:
        Grouping methods and properties within an object.

    ABSTRACTION:
        Some method and properties are hidden from the outside.

    INHERITANCE:
        Gets rid of redundant code

    POLYMORPHISM:
        Objects can have their own methods that share names with others
        eg. square, circle, and triangle objects can all have draw() but they're all unique to themselves

FACTORIES REFRESH:
    function createCircle(radius) {
        return {
            radius,
            draw() {
                console.log('draw');
            }
        }
    }
    const circle = createCircle(1);
    circle.draw();
    console.log(circle.radius);

CONSTRUCTORS REFRESH:
    function Circle(radius) {
        this.radius = radius;
        this.draw() {
            console.log('draw');
        }
    }

CONSTRUCTOR PROPERTIES:
    object.constructor gives me the function that constructed it
    





